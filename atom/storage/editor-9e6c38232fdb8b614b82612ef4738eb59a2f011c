{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":22,"width":1280,"height":774},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/mattgarrison/Projects/Rumble/crusher","buffers":[{"text":"require \"net/http\"\nrequire 'open-uri'\n\nclass WorkerController < ApplicationController\n  skip_before_filter :verify_authenticity_token, :only => [:git_webhook]\n\n\n  def gitrepo\n    url = Repo.build_github_url(worker_params['name'])\n    octorepo = Octokit::Repository.from_url(url)\n    @owner = Owner.find_or_create_by(name: octorepo.user)\n    @repo = Repo.find_or_create_by(owner: @owner, name: octorepo.repo)\n    #should check for errors\n    if @repo.save && @owner.save\n      GithubWorker.perform_async(@repo.id)\n      respond_to do |format|\n        flash[:notice] = \"Repository added to the queue.\"\n        format.html\n        #format.json\n      end\n    else\n      respond_to do |format|\n        flash[:notice] = \"Unable to extract owner and repository information.\"\n        format.html\n        #format.json\n      end\n    end\n  end\n\n  # TODO: Currently assumes this is coming from github only: Possibly security issue, too\n  def git_webhook\n    repo = params[:repository]\n    @owner = Owner.find_or_create_by(name: repo[:owner][:name])\n    @repo = Repo.find_or_create_by(owner: @owner, name: repo[:name])\n    if @repo.save && @owner.save\n      GithubWorker.perform_async(@repo.id)\n    end\n\n    render json: true\n  end\n\nprivate\n  def valid_repo_url?(repo_url)\n    # this is a bit redundant, but we plan to expand beyond github eventually\n    validity = false\n    if repo_url=~ /^github/\n      validity = valid_github_repo_name? build_github_url\n    end\n    validity\n  end\n\n  def worker_params\n    params.require('repo').permit(:name)\n  end\nend","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":48},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/worker_controller.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"07f12e45d1a55a5798b92dd830d8364bf96829b4","deserializer":"TextBuffer"},{"text":"class SessionsController < ApplicationController\n  def create\n    user = User.from_omniauth(env[\"omniauth.auth\"])\n    # TODO: Move sessions to server side and not cookies\n    session[:user_id] = user.id\n    redirect_to root_url, notice: \"Signed in!\"\n  end\n\n  def destroy\n    session[:user_id] = nil\n    redirect_to root_url, notice: \"Signed out!\"\n  end\nend","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":52},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/sessions_controller.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"b2f59e28c09c36d5a1ef42ca2794e987980d522d","deserializer":"TextBuffer"},{"text":"class UsersController < ApplicationController\n  before_action :authenticate_user!\n\n  def dashboard\n    @repos = current_user.repos\n  end\n\n  # TODO: this method and repos() need to be extracted into an API controller :(\n  def dashboard_data\n    @repos = current_user.repos\n    respond_to do |format|\n      format.json\n    end\n  end\n\n  # List Repos and Show Webhooks\n  def settings\n    @invalidate_repos_cache_path = \"#{invalidate_repos_cache_path}.json\"\n    @hook_repo_path = \"#{hook_repo_path}.json\"\n  end\n\n  def invalidate_repos_cache\n    Rails.cache.delete(\"user-#{current_user.id}-github-repo-list\")\n    respond_to do |format|\n      format.json { render json: [], status: :ok }\n    end\n  end\n\n  def repos\n    @repo_list = []\n    @repo_list = Rails.cache.fetch(\"user-#{current_user.id}-github-repo-list\", expires: 2.days) do\n      @repo_list = get_repo_list(current_user.auth_token)\n    end\n    respond_to do |format|\n      format.json { render :json => @repo_list }\n    end\n  end\n\n  def hook_repo\n    webhook_result = nil\n    client = Octokit::Client.new access_token: current_user.auth_token, client_id: Figaro.env.github_client, client_secret: Figaro.env.github_secret\n    # this shares much of the same logic as WorkerController#gitrepo\n    # it should be split into its own methods or call the WorkerController\n\n    repository = client.repository?(params[:repo_slug])\n    raise \"Repository not found. Connectivity error?\" if repository.nil?\n\n    @owner = Owner.find_or_create_by(name: repository.attrs[:owner][:login])\n    # after owner is found or created, add current_user to the m-n relation\n    @owner.users << current_user\n    @owner.save\n    current_user.owners << @owner\n    current_user.save\n    @repo = Repo.find_or_create_by(owner: @owner, name: repository.attrs[:name], is_private: repository.attrs[:private])\n    # if hook is true, we need to add the webhook to the repo\n    if params[:hook] == \"true\"\n      webhook_result = client.create_hook(\n        params[:repo_slug],\n        'web',\n        {\n          :url => worker_git_webhook_url, # resolves to http://crusher.io/worker/git_webhook',\n          :content_type => 'json'\n        },\n        {\n          :events => ['push', 'pull_request'],\n          :active => true\n        }\n      )\n      @repo.hook_id = webhook_result[:id] if webhook_result[:active]\n      @repo.save!\n    elsif params[:hook] == \"false\"\n      webhook_result = client.remove_hook(@repo.repo_slug, @repo.hook_id)\n    else\n      # return error status\n      webhook_result = false\n    end\n    # webhook_result should a json object telling us relevant details like\n    # if the webhook was created or removed successfully, if the repo was not found\n    # or if we did not have access to it, or if the post parameters were incorrect or insufficient\n    render json: webhook_result\n  end\n\n  private\n\n  # check the give repo to see if we're a hook\n  def is_hooked? repo\n    # TODO: This will only check github if we have it in our system first (for obvious speed reasons).\n    # Therefore whenever a hook is created, we must immediately create the repo locally\n\n    # TODO: Current system does O(n) SQL queries on local, we can grab all repos in one SQL hit, and then do in-memory checks\n    # The following base code could be cached with ||= to handle once and then .includes? in memmory\n    # owners = Owner.where(name: repo.owner.login)          # Returns all possible owners\n    # owners.each {|owner| @r += owner.repos.map(&:name) }  # Returns all repo names in an array\n    if Repo.where(name: repo.name).size > 0\n      github_hooked? repo\n    else\n      false\n    end\n  end\n\n  def github_hooked? repo\n    begin\n      hooks = @client.hooks(repo.full_name)\n      crusher_hooks = hooks.select { |hook| hook.name == \"web\" && hook.active == true }\n    rescue\n      crusher_hooks = []\n    end\n    crusher_hooks.count > 0\n  end\n\n\n  def get_repo_list(auth_token)\n    @client = Octokit::Client.new(access_token: auth_token, client_id: Figaro.env.github_client, client_secret: Figaro.env.github_secret)\n    repos = @client.user.rels[:repos].get.data\n    #Add all user's org repos\n    orgs  = @client.user.rels[:organizations].get.data\n    orgs.each do |org|\n      repos += org.rels[:repos].get.data\n    end\n    # Now we have EVERYTHING, so make that repo_list (filter for ones we can push to)\n    repos.each do |repo|\n      crush_owner = Owner.where(name: repo.owner.login).first\n      crush_repo = Repo.find_or_create_by!(name: repo.name, owner_id: crush_owner.id, is_private: repo.private)\n      repo_link = repo_repos_url(crush_owner.name, crush_repo.name) if crush_repo\n      @repo_list << {slug: repo.full_name, hooked: is_hooked?(repo), internal_link: repo_link} if repo.permissions.push\n    end\n    @repo_list.to_json\n  end\n\nend\n\n\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":56},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/users_controller.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"9808b8f1bd29bd7eac2ee3ac5e15d50df00900ba","deserializer":"TextBuffer"},{"text":"class HomeController < ApplicationController\n  def index\n    if current_user.nil?\n      @repo = Repo.new\n      @recent_repos = Repo.recent(5)\n      render 'home/index'\n    else\n      @repos = current_user.repos\n      render 'home/user_index', layout: 'user_application'\n    end\n  end\n\n  def faq\n  end\n\n  def about\n  end\n\n  def contact\n  end\n\n  def pricing\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":60},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/home_controller.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"ec8ebc08b41efd58bfe863ef8fb2b802a1ea55c8","deserializer":"TextBuffer"},{"text":"class ApplicationController < ActionController::Base\n  # Prevent CSRF attacks by raising an exception.\n  # For APIs, you may want to use :null_session instead.\n  protect_from_forgery with: :exception\n  after_filter :set_csrf_cookie_for_ng\n\n  def peek_enabled?\n    current_admin\n  end\n\nprotected\n\n  # Used to let Angular code send POSTs without needing to modify clientside code to accomodate Rails specifically\n  def verified_request?\n    super || form_authenticity_token == request.headers['X-XSRF-TOKEN']\n  end\n\nprivate\n\n  def current_user\n    @current_user ||= User.find(session[:user_id]) if session[:user_id]\n  end\n  helper_method :current_user\n\n  def authenticate_user!\n    current_user()\n\n    if @current_user.nil?\n      Rails.logger.info \"We need to authorize this first\"\n      redirect_to root_path\n    else\n      Rails.logger.info \"We do not need to authorize this first\"\n    end\n  end\n\n\n  # Used to let Angular code send POSTs without needing to modify clientside code to accomodate Rails specifically\n  def set_csrf_cookie_for_ng\n    cookies['XSRF-TOKEN'] = form_authenticity_token if protect_against_forgery?\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[9,0],[9,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":64,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/application_controller.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"6862f805670a1abf8bd37b6e353617fab7c28aa5","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":48,"softTabs":true,"displayBuffer":{"id":49,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/worker_controller.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":52,"softTabs":true,"displayBuffer":{"id":53,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/sessions_controller.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":56,"softTabs":true,"displayBuffer":{"id":57,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/users_controller.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":60,"softTabs":true,"displayBuffer":{"id":61,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/home_controller.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":64,"softTabs":true,"displayBuffer":{"id":65,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/application_controller.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/application_controller.rb","focused":true,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-ruby"],"deserializer":"Workspace"},"packageStates":{"command-logger":{"eventLog":{"application:quit":{"count":1,"name":"application:quit","lastRun":1407179655582}}},"fuzzy-finder":{"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/worker_controller.rb":1407179639528,"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/sessions_controller.rb":1407179642803,"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/users_controller.rb":1407179643508,"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/home_controller.rb":1407179644241,"/Users/mattgarrison/Projects/Rumble/crusher/app/controllers/application_controller.rb":1407179646480},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":27925},"tree-view":{"directoryExpansionStates":{"app":{"controllers":{"repo":{}},"workers":{}}},"selectedPath":"/Users/mattgarrison/Projects/Rumble/crusher/app/workers","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":26,"width":200}}}