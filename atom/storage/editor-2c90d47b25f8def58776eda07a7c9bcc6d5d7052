{"mode":"editor","version":1,"windowDimensions":{"x":262,"y":-925,"width":1346,"height":825},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/mattgarrison/Projects/apps/carabiner","buffers":[{"text":"require 'bubble-wrap/core'\n\nrequire 'motion-require'\n\nMotion::Require.all(Dir.glob(File.expand_path('../carabiner/**/*.rb', __FILE__)))","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":25,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[{"patches":[{"oldRange":[[0,0],[0,2]],"newRange":[[0,0],[0,0]],"oldText":"# ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"}],"deserializer":"History"},"filePath":"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"c9d3b938e577b6767681346ff25d7578370e5f95","deserializer":"TextBuffer"},{"text":"module Carabiner\n  class KeychainReturnCodeException < Exception\n\n    attr_accessor :return_code\n\n    RETURN_CODES = {\n      ErrSecSuccess => {:constant_name => 'ErrSecSuccess', :message => \"No error.\"},\n      ErrSecUnimplemented => {:constant_name => 'ErrSecUnimplemented', :message => \"Function or operation not implemented.\"},\n      ErrSecParam => {:constant_name => 'ErrSecParam', :message => \"One or more parameters passed to the function were not valid.\"},\n      ErrSecAllocate => {:constant_name => 'ErrSecAllocate', :message => \"Failed to allocate memory.\"},\n      ErrSecNotAvailable => {:constant_name => 'ErrSecNotAvailable', :message => \"No trust results are available.\"},\n      ErrSecAuthFailed => {:constant_name => 'ErrSecAuthFailed', :message => \"Authorization/Authentication failed.\"},\n      ErrSecDuplicateItem => {:constant_name => 'ErrSecDuplicateItem', :message => \"The item already exists.\"},\n      ErrSecItemNotFound => {:constant_name => 'ErrSecItemNotFound', :message => \"The item cannot be found.\"},\n      ErrSecInteractionNotAllowed => {:constant_name => 'ErrSecInteractionNotAllowed', :message => \"Interaction with the Security Server is not allowed.\"},\n      ErrSecDecode => {:constant_name => 'ErrSecDecode', :message => \"Unable to decode the provided data.\"}\n    }\n\n    def initialize message, return_code\n      @return_code = return_code\n      super message\n    end\n\n    def message\n      super + \"\\nReturn Code: #{constant_name} (#{return_message})\"\n    end\n\n    def return_message\n      if return_code_item\n        return_code_item[:message]\n      else\n        \"Keychain return code #{return_code} unknown.\"\n      end\n    end\n\n    def constant_name\n      if return_code_item\n        return_code_item[:constant_name]\n      else\n        return_code.to_s\n      end\n    end\n\n    def return_code_item\n      RETURN_CODES[return_code]\n    end\n  end\nend","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":29},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner/keychain_return_code_exception.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"3f0db3a404b3c746adb94176cb83374efe4d1ae4","deserializer":"TextBuffer"},{"text":"module Carabiner\n  class InternetPasswordItem < BaseItem\n    # These are the default constants and their respective types,\n    # available for the KSecClassInternetPassword Keychain Item class:\n    #\n    # See the header file Security/SecItem.h for more details.\n    attributes({\n                 # The corresponding value is of type CFStringRef and indicates which access group an item is in. Access groups can be used to share keychain items among two or more applications. For applications to share a keychain item, the applications must have a common access group listed in their keychain-access-groups entitlement, and the application adding the shared item to the keychain must specify this shared access-group name as the value for this key in the dictionary passed to the SecItemAdd function.\n                 # An application can be a member of any number of access groups. By default, the SecItemUpdate, SecItemDelete, and SecItemCopyMatching functions search all the access groups an application is a member of. Include this key in the search dictionary for these functions to specify which access group is searched.\n                 # A keychain item can be in only a single access group.\n                 access_group: KSecAttrAccessGroup,\n\n                 # The corresponding value is of type CFDateRef and represents the date the item was created. Read only.\n                 creation_time: KSecAttrCreationDate,\n\n                 # The corresponding value is of type CFDateRef and represents the last time the item was updated. Read only.\n                 modifaction_date: KSecAttrModificationDate,\n\n                 # The corresponding value is of type CFStringRef and specifies a user-visible string describing this kind of item (for example, \"Disk image password\").\n                 description: KSecAttrDescription,\n\n                 # The corresponding value is of type CFStringRef and contains the user-editable comment for this item.\n                 comment: KSecAttrComment,\n\n                 # The corresponding value is of type CFNumberRef and represents the item's creator. This number is the unsigned integer representation of a four-character code (for example, 'aCrt').\n                 creator: KSecAttrCreator,\n\n                 # The corresponding value is of type CFStringRef and contains the user-visible label for this item.\n                 type: KSecAttrType,\n\n                 # The corresponding value is of type CFStringRef and contains the user-visible label for this item.\n                 label: KSecAttrLabel,\n\n                 # The corresponding value is of type CFBooleanRef and is kCFBooleanTrue if the item is invisible (that is, should not be displayed).\n                 is_invisible: KSecAttrIsInvisible,\n\n                 # The corresponding value is of type CFBooleanRef and indicates whether there is a valid password associated with this keychain item. This is useful if your application doesn't want a password for some particular service to be stored in the keychain, but prefers that it always be entered by the user.\n                 is_negative: KSecAttrIsNegative,\n\n                 # The corresponding value is of type CFStringRef and contains an account name. Items of class kSecClassGenericPassword and kSecClassInternetPassword have this attribute.\n                 account: KSecAttrAccount,\n\n                 # The corresponding value is of type CFStringRef and represents the Internet security domain. Items of class kSecClassInternetPassword have this attribute.\n                 security_domain: KSecAttrSecurityDomain,\n\n                 # The corresponding value is of type CFStringRef and contains the server's domain name or IP address. Items of class kSecClassInternetPassword have this attribute.\n                 server: KSecAttrServer,\n\n                 # The corresponding value is of type CFNumberRef and denotes the protocol for this item (see “Protocol Values”). Items of class kSecClassInternetPassword have this attribute.\n                 protocol: KSecAttrProtocol,\n\n                 # The corresponding value is of type CFNumberRef and denotes the authentication scheme for this item (see “Authentication Type Values”).\n                 authentication_type: KSecAttrAuthenticationType,\n\n                 # The corresponding value is of type CFNumberRef and represents an Internet port number. Items of class kSecClassInternetPassword have this attribute.\n                 port: KSecAttrPort,\n\n                 # The corresponding value is of type CFStringRef and represents a path, typically the path component of the URL. Items of class kSecClassInternetPassword have this attribute.\n                 path: KSecAttrPath,\n\n                 # Data attribute key. A persistent reference to a credential can be stored on disk for later use or passed to other processes.\n                 # The corresponding value is of type CFDataRef.  For keys and password items, the data is secret (encrypted) and may require the user to enter a password for access.\n                 password: KSecValueData\n               })\n\n    sec_class KSecClassInternetPassword\n\n    def self.authentication_type_values\n      {\n        ntlm: KSecAttrAuthenticationTypeNTLM,\n        msn: KSecAttrAuthenticationTypeMSN,\n        dpa: KSecAttrAuthenticationTypeDPA,\n        rpa: KSecAttrAuthenticationTypeRPA,\n        http_basic: KSecAttrAuthenticationTypeHTTPBasic,\n        http_digest: KSecAttrAuthenticationTypeHTTPDigest,\n        html_form: KSecAttrAuthenticationTypeHTMLForm,\n        default: KSecAttrAuthenticationTypeDefault\n      }\n    end\n\n    def self.protocol_values\n      {\n        ftp: KSecAttrProtocolFTP,\n        ftp_account: KSecAttrProtocolFTPAccount,\n        http: KSecAttrProtocolHTTP,\n        irc: KSecAttrProtocolIRC,\n        nntp: KSecAttrProtocolNNTP,\n        pop3: KSecAttrProtocolPOP3,\n        smtp: KSecAttrProtocolSMTP,\n        socks: KSecAttrProtocolSOCKS,\n        imap: KSecAttrProtocolIMAP,\n        ldap: KSecAttrProtocolLDAP,\n        apple_talk: KSecAttrProtocolAppleTalk,\n        afp: KSecAttrProtocolAFP,\n        telnet: KSecAttrProtocolTelnet,\n        ssh: KSecAttrProtocolSSH,\n        ftps: KSecAttrProtocolFTPS,\n        https: KSecAttrProtocolHTTPS,\n        http_proxy: KSecAttrProtocolHTTPProxy,\n        https_proxy: KSecAttrProtocolHTTPSProxy,\n        ftp_proxy: KSecAttrProtocolFTPProxy,\n        smb: KSecAttrProtocolSMB,\n        rtsp: KSecAttrProtocolRTSP,\n        rtsp_proxy: KSecAttrProtocolRTSPProxy,\n        daap: KSecAttrProtocolDAAP,\n        eppc: KSecAttrProtocolEPPC,\n        ipp: KSecAttrProtocolIPP,\n        nntps: KSecAttrProtocolNNTPS,\n        ldaps: KSecAttrProtocolLDAPS,\n        telnet_s: KSecAttrProtocolTelnetS,\n        imaps: KSecAttrProtocolIMAPS,\n        ircs: KSecAttrProtocolIRCS,\n        pop3_s: KSecAttrProtocolPOP3S\n      }\n    end\n\n    def protocol_sym\n      self.class.protocol_values.find {|k, v| v == @protocol }.first if @protocol\n    end\n\n    def protocol=(value)\n      if self.class.protocol_values.values.include? value\n        @protocol = value\n      else\n        new_protocol = self.class.protocol_values.find {|k, v| k == value }\n        @protocol = new_protocol.last if new_protocol\n      end\n    end\n\n    def authentication_type_sym\n      self.class.authentication_type_values.find {|k, v| v == @authentication_type }.first if @authentication_type\n    end\n\n    def authentication_type=(value)\n      if self.class.authentication_type_values.values.include? value\n        @authentication_type = value\n      else\n        new_authentication_type = self.class.authentication_type_values.find {|k, v| k == value }\n        @authentication_type = new_authentication_type.last if new_authentication_type\n      end\n    end\n\n    def reset!\n      super\n      self.account     = ''\n      self.label       = ''\n      self.description = ''\n      self.password    = ''\n      true\n    end\n  end\nend","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":33},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner/internet_password_item.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"aedebf8b43888ac63d6c44efe179902e386e6d9e","deserializer":"TextBuffer"},{"text":"module Carabiner\n  class BaseItem\n    attr_accessor :query, :persistent, :identifiers\n\n    def self.attributes(attrs = nil)\n      if attrs\n        @attributes = attrs\n        attr_accessor *attrs.keys\n      else\n        @attributes ||= {}\n      end\n    end\n\n    def self.sec_class sec_class = nil\n      @sec_class ||= sec_class\n    end\n\n    NoErr = 0\n\n    def initialize identifiers\n      @identifiers = identifiers\n      reset_to_identifiers\n\n      self.query = data\n      query[KSecClass] = self.class.sec_class\n\n      if BubbleWrap::Device.simulator?\n        query.delete(KSecAttrAccessGroup)\n      end\n\n      query[KSecMatchLimit] = KSecMatchLimitOne\n      query[KSecReturnAttributes] = KCFBooleanTrue\n\n      tempQuery = NSDictionary.dictionaryWithDictionary query\n      outDictionaryPtr = Pointer.new(:object)\n      if !(SecItemCopyMatching(tempQuery, outDictionaryPtr) == NoErr)\n        reset!\n        self.data = self.data.merge identifiers\n        self.persistent = false\n\n        unless Device.simulator?\n          query[KSecAttrAccessGroup] = identifiers[:access_group]\n        end\n      else\n        self.persistent = true\n        self.data = secItemFormatToDictionary(outDictionaryPtr[0])\n      end\n    end\n\n    def save!\n      writeToKeychain\n      self.persistent = true\n      true\n    end\n\n    def delete!\n      if persistent?\n        tempDictionary = dictionaryToSecItemFormat(data)\n        result = SecItemDelete(tempDictionary)\n        if result != NoErr && result != ErrSecItemNotFound\n          raise KeychainReturnCodeException.new \"Problem deleting current dictionary.\", result\n        end\n        self.persistent = false\n      end\n      self.data = {}\n      true\n    end\n\n    def reset!\n      delete! unless data.empty?\n      reset_to_identifiers\n      true\n    end\n\n    def self.key_accepted? key\n      attributes.values.include? key\n    end\n\n    def persistent?\n      persistent\n    end\n\n    def data\n      self.class.attributes.keys.inject({}) do |memo, getter_name|\n        constant = self.class.attributes[getter_name]\n        value    = send(getter_name)\n        memo[constant] = value if value\n        memo\n      end\n    end\n\n    def data=(hash)\n      self.class.attributes.each do |getter_name, constant|\n        send(\"#{getter_name}=\", hash[constant])\n      end\n    end\n\n    private\n\n    def reset_to_identifiers\n      identifiers.each do |getter_name, value|\n        send(\"#{getter_name}=\", value)\n      end\n    end\n\n    def dictionaryToSecItemFormat dictionaryToConvert\n      returnDictionary = NSMutableDictionary.dictionaryWithDictionary dictionaryToConvert\n      returnDictionary[KSecClass] = self.class.sec_class\n      passwordString = dictionaryToConvert[KSecValueData]\n\n      returnDictionary[KSecValueData] = passwordString.dataUsingEncoding(NSUTF8StringEncoding)\n      returnDictionary\n    end\n\n    def secItemFormatToDictionary dictionaryToConvert\n      returnDictionary = NSMutableDictionary.dictionaryWithDictionary dictionaryToConvert\n      returnDictionary[KSecReturnData] = KCFBooleanTrue\n      returnDictionary[KSecClass] = self.class.sec_class\n\n      passwordDataPtr = Pointer.new(:object)\n\n      result = SecItemCopyMatching(returnDictionary, passwordDataPtr)\n      if result == NoErr\n        returnDictionary.delete KSecReturnData\n        passwordData = passwordDataPtr[0]\n        password = NSString.alloc.initWithBytes(passwordData.bytes, length: passwordData.length, encoding: NSUTF8StringEncoding)\n        returnDictionary[KSecValueData] = password\n      else\n        raise KeychainReturnCodeException.new \"Serious error, no matching item found in the keychain.\", result\n      end\n\n      returnDictionary\n    end\n\n    def writeToKeychain\n      attributesPtr = Pointer.new(:object)\n      if SecItemCopyMatching(query, attributesPtr) == NoErr\n        query = NSMutableDictionary.dictionaryWithDictionary attributesPtr[0]\n\n        query[KSecClass] = self.class.sec_class\n        attributes_to_update = dictionaryToSecItemFormat data\n        attributes_to_update.delete_if { |key, value| !self.class.key_accepted? key }\n\n        if Device.simulator?\n          attributes_to_update.delete KSecAttrAccessGroup\n        end\n\n        result = SecItemUpdate(query, attributes_to_update)\n        unless result == NoErr\n          raise KeychainReturnCodeException.new \"Couldn't update the Keychain Item.\", result\n        end\n      else\n        result = SecItemAdd(dictionaryToSecItemFormat(data), nil)\n        unless result == NoErr\n          raise KeychainReturnCodeException.new \"Couldn't add the Keychain Item.\", result\n        end\n      end\n    end\n  end\nend","markers":{"markers":{"1":{"id":1,"range":[[113,0],[113,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":37,"goalBufferRange":null,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner/base_item.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"a10017fc74c72bcf3ecbafa7a91f23455727c9ff","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":25,"softTabs":true,"displayBuffer":{"id":26,"softWrap":false,"editorWidthInChars":124,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":29,"softTabs":true,"displayBuffer":{"id":30,"softWrap":false,"editorWidthInChars":124,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner/keychain_return_code_exception.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":33,"softTabs":true,"displayBuffer":{"id":34,"softWrap":false,"editorWidthInChars":124,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner/internet_password_item.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":37,"softTabs":true,"displayBuffer":{"id":38,"softWrap":false,"editorWidthInChars":124,"scrollTop":1864,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner/base_item.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner/base_item.rb","focused":false,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"command-logger":{"eventLog":{"core:move-down":{"count":7,"name":"core:move-down","lastRun":1404916800638},"tree-view:expand-directory":{"count":1,"name":"tree-view:expand-directory","lastRun":1404916798547},"tree-view:open-selected-entry":{"count":1,"name":"tree-view:open-selected-entry","lastRun":1404916802254},"core:move-up":{"count":1,"name":"core:move-up","lastRun":1404916803957},"editor:toggle-line-comments":{"count":1,"name":"editor:toggle-line-comments","lastRun":1404916806922},"core:undo":{"count":1,"name":"core:undo","lastRun":1404916808146},"core:copy":{"count":5,"name":"core:copy","lastRun":1404917698813},"find-and-replace:show":{"count":2,"name":"find-and-replace:show","lastRun":1404916907231},"core:confirm":{"count":10,"name":"core:confirm","lastRun":1404916914235}}},"find-and-replace":{"viewState":{"findHistory":["sec_class"],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}}},"fuzzy-finder":{"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner.rb":1404916802539,"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner/keychain_return_code_exception.rb":1404916812011,"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner/internet_password_item.rb":1404916813808,"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner/base_item.rb":1404916819135},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":6720443},"tree-view":{"directoryExpansionStates":{"lib":{"carabiner":{}}},"selectedPath":"/Users/mattgarrison/Projects/apps/carabiner/lib/carabiner/base_item.rb","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}